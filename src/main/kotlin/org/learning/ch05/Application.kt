package org.learning.ch05

//Lambda expressions, or simply lambdas, are essentially small chunks of code that can be passed to other functions.
fun main(args: Array<String>) {
    val people = listOf(Person("Alice", 29), Person("Bob", 31))
    findTheOldest(people)
    println(people.maxBy { it.age }) // "it" is an autogenerated argument name.
    println(people.maxBy(Person::age))

    val sum = { x: Int, y: Int -> x + y }
    println(sum(1, 2))

    run { println(42) }
    println(people.maxBy({ p: Person -> p.age }))
    println(people.maxBy() { p: Person -> p.age })
    println(people.maxBy { p: Person -> p.age }) //When the lambda is the only argument to a function
    // the shortest syntax
    println(people.maxBy { p -> p.age })

    val errors = listOf("403 Forbidden", "404 Not Found")
    printMessagesWithPrefix(errors, "Error:")

    val responses = listOf("200 OK", "418 I'm a teapot", "500 Internal Server Error")
    printProblemCounts(responses)

    // constructor reference
    val createPerson = ::Person
    val p = createPerson("Alice", 29)
    println(p)

    val b = Person("Dmitry", 34)
    val personAgeFunction = Person::age
    println(personAgeFunction(b))

    val dmitryAgeFunction = b::age
    println(dmitryAgeFunction())

    // Filter
    val list = listOf(1,2,3,4)
    println(list.filter { it % 2 == 0 })

    println(people.filter { it.age > 30 })

    // map
    println(list.map { it * it })
    println(people.map { it.name })
    println(people.map(Person::name))
    println(people.filter { it.age > 30 }.map(Person::name))

    //println(people.filter { it.age == people.maxBy(Person::age)!!.age}) //if there are 100 people the search for the maximum age will be performed 100 times!
    val maxAge = people.maxBy(Person::age)!!.age
    people.filter { it.age == maxAge }

    val numbers = mapOf(0 to "zero", 1 to "one")
    println(numbers.mapValues { it.value.toUpperCase() })

    // all, any, count and find: applying a predicate to a collection
    val canBeInClub27 = { p: Person -> p.age <= 27 }
    println(people.all(canBeInClub27))
    println(people.any(canBeInClub27)) // Note that !all (not- all ) can be replaced with any with a negated condition, and vice versa.

    val listNum = listOf(1,2,3)
    println(!list.all { it == 3 }) //The negation ! isn’t noticeable, so it’s better to use "any" in this case.
    println(list.any { it != 3 }) //The condition in the argument has changed to its opposite.

    println(people.count(canBeInClub27))

    val listpep = listOf(Person("Alice", 31),
        Person("Bob", 29), Person("Carol", 31))
    println(listpep.groupBy { it.age })

    val listAlphabet = listOf("a", "ab", "b")
    println(listAlphabet.groupBy(String::first))

    // flatMap, flatten
    val strings = listOf("abc", "def")
    println(strings.flatMap { it.toList() })

    val books = listOf(Book("Thursday Next", listOf("Jasper Fforde")),
            Book("Mort", listOf("Terry Pratchett")), Book("Good Omens", listOf("Terry Pratchett", "Neal Gaiman")))
    println(books.flatMap { it.authors }.toSet())

    // Lazy collection operations: sequences
    println(people.map(Person::name).filter { it.startsWith("A") })
    println(people.asSequence().map(Person::name).filter { it.startsWith("A") }.toList())

    println(listOf(1, 2, 3, 4).asSequence()
            .map { print("map($it) "); it * it }
            .filter { print("filter($it) "); it % 2 == 0 }
            .toList() // terminal operation causes all the postponed computations to be performed.
    )

    // Creating sequences
    val naturalNumbers = generateSequence(0) { it + 1 }
    val numbersTo100 = naturalNumbers.takeWhile { it <= 100 }
    println(numbersTo100.sum())

    println(alphabetRefacor())
    println(alphabetFinal())
    println(alphabetApply())
    println(alphabetBuilString())
}

data class Person(val name: String, val age: Int)

fun findTheOldest(people: List<Person>) {
    var maxAge = 0
    var theOldest: Person? = null
    for (person in people) {
        if (person.age > maxAge) {
            maxAge = person.age
            theOldest = person
        }
    }
    println(theOldest)
}

// Syntax for lambda expressions
/*
{ x: Int, y: Int -> x + y } // always with curly braces
 |  parameters |  | body |
*/

fun printMessagesWithPrefix(messages: Collection<String>, prefix: String) {
    messages.forEach {
        println("$prefix $it")
    }
}

fun printProblemCounts(responses: Collection<String>) {
    var clientErrors = 0
    var serverErrors = 0
    responses.forEach {
        if (it.startsWith("4")) {
            clientErrors++
        } else if (it.startsWith("5")) {
            serverErrors++
        }
    }
    println("$clientErrors client errors, $serverErrors server errors")
}

// Member references
/*
* Person::age // separated by ::
* class   member
*
* val getAge = { person: Person -> person.age }
* people.maxBy(Person::age)
*
* fun salute() = println("Salute!")
* >>> run(::salute) // Reference to the top-level function
    Salute!
*
* val action = { person: Person, message: String -> // This lambda delegates to a sendEmail function.
*   sendEmail(person, message)
* }
* val nextAction = ::sendEmail // You can use a member reference instead
* */

fun Person.isAdult() = age >= 21

// flatMap and flatten: processing elements in nested collections
class Book(val title: String, val authors: List<String>)
//books.flatMap { it.authors }.toSet() //Set of all authors who wrote "books"

// Executing sequence operations: intermediate and terminal operations
/*
    sequence.map {...}.filter {...}.toList()
            |intermediate operations| terminal operation
*/

//Passing a lambda as a parameter to a Java method
/* Java */
//void postponeComputation(int delay, Runnable computation);
//postponeComputation(1000) { println(42) }
//postponeComputation(1000, object : Runnable { override fun run() { println(42) })
//val runnable = Runnable { println(42) }
//fun handleComputation() {
//    postponeComputation(1000, runnable)
//}

// SAM constructors: explicit conversion of lambdas to functional interfaces
fun createAllDoneRunnable() : Runnable {
    return Runnable { println("All done!") }
}
/*
>>> createAllDoneRunnable().run()
All done!
*/

// Lambdas with receivers: with and apply
    //The `with` function
fun alphabet(): String {
    val result = StringBuilder()
    for(letter in 'A'..'Z') {
        result.append(letter)
    }
    result.append("\nNow I know the alphabet!")
    return result.toString()
}

/*
>>> println(alphabet())
ABCDEFGHIJKLMNOPQRSTUVWXYZ
Now I know the alphabet!
*/

fun alphabetRefacor(): String {
    val stringBuilder = StringBuilder()
    return with (stringBuilder) { //Specifies the receiver value on which you’re calling the methods
        for(letter in 'A'..'Z') {
            this.append(letter) //Calls a method on the receiver value though an explicit "this"
        }
        append("\nNow I know the alphabet!") // Calls a method, omitting "this"
        this.toString() //Returns a value from the lambda
    }
}

fun alphabetFinal() = with(StringBuilder()) {
    for(letter in 'A'..'Z') {
        append(letter) //Calls a method on the receiver value though an explicit "this"
    }
    append("\nNow I know the alphabet!") // Calls a method, omitting "this"
    toString() //Returns a value from the lambda
}

// The `apply` function
/*
* The apply function works almost exactly the same as with ; the only difference is that
apply() always returns the object passed to it as a parameter (in other words, the
receiver object)
*/
fun alphabetApply() = StringBuilder().apply {
    for(letter in 'A'..'Z') {
        append(letter) //Calls a method on the receiver value though an explicit "this"
    }
    append("\nNow I know the alphabet!")
}.toString()

fun alphabetBuilString() = buildString {
    for(letter in 'A'..'Z') {
        this.append(letter)
    }
    append("\nNow I know the alphabet!")
}

/*Summary
*
* - Lambdas allow you to pass chunks of code as parameters to methods.
* - Kotlin lets you pass lambdas to methods outside of parentheses and refer to a single lambda parameter as it .
* - Code in a lambda can access and modify variables in the function containing the call to the lambda.
* - You can create references to methods, constructors, and properties by prefixing the name
    of the function with :: , and pass such references to methods instead of lambdas.
  - Most common operations with collections can be performed without manually iterating
    over elements, using functions such as filter , map , all , any , and so on.
* - Sequences allow you to combine multiple operations on a collection without creating
    collections to hold intermediate results.
* - You can pass lambdas as arguments to methods that take a Java functional interface (an
    interface with a single abstract method, also known as a SAM interface) as a parameter.
* - Lambdas with receivers are lambdas in which you can directly call methods on a special receiver object.
* - The with standard library function allows you to call multiple methods on the same
    object without repeating the reference to the object. apply lets you construct and
    initialize any object using a builder-style API.
* */
